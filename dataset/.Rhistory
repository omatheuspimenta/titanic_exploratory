name_ecsd <- paste("er_ecsd_n_",vertex,"_p_", p, sep = "")
name_ecsd_rbind <- paste("er_ecsd_rbind_n_",vertex,"_p_", p, sep = "")
temp_adj <- matrix(nrow = max_iter,
ncol = vertex)
temp_adj_comp <- matrix(nrow = max_iter,
ncol = vertex)
temp_lap <- matrix(nrow = max_iter,
ncol = vertex)
temp_lapn <- matrix(nrow = max_iter,
ncol = vertex)
temp_density <- list()
temp_Bline <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_B_eigen <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_B_eigen_resc <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_ecsd <- list()
temp_ecsd_rbind <- matrix(nrow = length_int,
ncol = length_int)
for (iter in 1:max_iter){
# of adjacency matrix
g_erdp <- erdos.renyi.game(n=vertex,
p.or.m=p,
type = c("gnp"),
directed = FALSE,
loops = FALSE)
s_erdp <- eigen(as_adj(g_erdp))
temp_adj[iter,] <- s_erdp$values
# of complementary adjacency matrix
ones_erdp <- matrix(data=1,
nrow=vertex,
ncol=vertex)
cam_erdp <- ones_erdp - as_adj(g_erdp)
scam_erdp <- eigen(cam_erdp)
temp_adj_comp[iter,] <- scam_erdp$values
# of laplacian matrix
lm_erdp <- laplacian_matrix(g_erdp,
normalized = FALSE)
sl_erdp <- eigen(lm_erdp)
temp_lap[iter,] <- sl_erdp$values
# of normalized laplacian matrix
lmn_erdp <- laplacian_matrix(g_erdp,
normalized = TRUE)
sln_erdp <- eigen(lmn_erdp)
temp_lapn[iter,] <- sln_erdp$values
# of spectrum density
#temp_density[[iter]] <- fast.spectral.density(g_erdp,
#                                              npoints = npoints, # refinar mais essa busca
#                                              numCores = numCores)
# of classifier article
Bline <- createBline(g_erdp)
Bline_eigen <- eigen(Bline)
temp_Bline[iter,] <- Bline_eigen$values
absolute_eigen <- base::Mod(Bline_eigen$values)
log_base <- max(absolute_eigen) # the spectral radius
rescale_eigen <- log(absolute_eigen,
base = log_base)
temp_B_eigen[iter,] <- rescale_eigen
temp_B_eigen_resc[iter,] <- complex(modulus = rescale_eigen,
argument = Arg(Bline_eigen$values))
temp_ecsd[[iter]] <- ecsd(r_interval = r_int,
pi_interval = pi_int,
rescale_eigen = rescale_eigen,
n = vertex,
Bline_eigen = Bline_eigen)
temp_ecsd_rbind <- rbind(temp_ecsd_rbind, temp_ecsd[[iter]])
}
assign(name_adj, temp_adj)
remove(temp_adj, s_erdp)
assign(name_adj_comp, temp_adj_comp)
remove(temp_adj_comp, scam_erdp, ones_erdp, cam_erdp)
assign(name_lap, temp_lap)
remove(temp_lap, sl_erdp, lm_erdp)
assign(name_lapn, temp_lapn)
remove(temp_lapn, sln_erdp, lmn_erdp)
assign(name_dens, temp_density)
remove(temp_density, name_dens)
assign(name_Bline, temp_Bline)
assign(name_B_eigen, temp_B_eigen)
assign(name_B_eigen_resc, temp_B_eigen_resc)
assign(name_ecsd, temp_ecsd)
temp_ecsd_rbind<-temp_ecsd_rbind[rowSums(is.na(temp_ecsd_rbind)) != ncol(temp_ecsd_rbind),]
assign(name_ecsd_rbind, temp_ecsd_rbind)
remove(Bline, Bline_eigen, temp_Bline, absolute_eigen, log_base, temp_B_eigen,
temp_B_eigen_resc, temp_ecsd, temp_ecsd_rbind)
}
}
remove(g_erdp, iter, n_vertex, max_iter, p, name_adj,
name_adj_comp, name_lap, name_lapn, prob, vertex,
name_Bline, name_B_eigen, name_B_eigen_resc,
rescale_eigen, createBline, ecsd, name_ecsd,
name_ecsd_rbind)
View(er_ecsd_rbind_n_100_p_0.1)
View(er_ecsd_rbind_n_100_p_0.3)
library(igraph)
library(statGraph)
source("/home/matheus/Dropbox/06_doutorado/simulations/graph_spectrum/createBline.R")
source("/home/matheus/Dropbox/06_doutorado/simulations/graph_spectrum/createECSD.R")
create_interval <- function(from, to, length.out) {
length.out <- length.out + 1
result <- seq(from, to, length.out = length.out)
result <- result[-1]
return(result)
}
# mudar depois para refinar mais o interval
length_int <- 10
npoints <- 20
numCores <- 2
## ERDOS-RENYI with probabilities
n_vertex <- c(100,200)#,500,1000,5000,10000)
prob <- c(0.1, 0.3)#, 0.5, 0.7, 0.9)
max_iter <- 10#00
r_int <- create_interval(0,1,length_int)
pi_int <- create_interval(0,pi,length_int)
for (vertex in n_vertex){
for (p in prob){
name_adj <- paste("er_eigen_adj_n_",vertex,"_p_", p, sep = "")
name_adj_comp <- paste("er_eigen_adjcomple_n_",vertex,"_p_", p, sep = "")
name_lap <- paste("er_eigen_laplac_n_",vertex,"_p_", p, sep = "")
name_lapn <- paste("er_eigen_laplacNorm_n_",vertex,"_p_", p, sep = "")
name_dens <- paste("er_density_n_",vertex,"_p_", p, sep = "")
name_Bline <- paste("er_BLine_n_",vertex,"_p_", p, sep = "")
name_B_eigen <- paste("er_B_eigenReal_n_",vertex,"_p_", p, sep = "")
name_B_eigen_resc <- paste("er_B_eigen_R_and_Im_n_",vertex,"_p_", p, sep = "")
name_ecsd <- paste("er_ecsd_n_",vertex,"_p_", p, sep = "")
name_ecsd_rbind <- paste("er_ecsd_rbind_n_",vertex,"_p_", p, sep = "")
temp_adj <- matrix(nrow = max_iter,
ncol = vertex)
temp_adj_comp <- matrix(nrow = max_iter,
ncol = vertex)
temp_lap <- matrix(nrow = max_iter,
ncol = vertex)
temp_lapn <- matrix(nrow = max_iter,
ncol = vertex)
temp_density <- list()
temp_Bline <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_B_eigen <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_B_eigen_resc <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_ecsd <- list()
temp_ecsd_rbind <- matrix(nrow = length_int,
ncol = length_int)
for (iter in 1:max_iter){
# of adjacency matrix
g_erdp <- erdos.renyi.game(n=vertex,
p.or.m=p,
type = c("gnp"),
directed = FALSE,
loops = FALSE)
s_erdp <- eigen(as_adj(g_erdp))
temp_adj[iter,] <- s_erdp$values
# of complementary adjacency matrix
ones_erdp <- matrix(data=1,
nrow=vertex,
ncol=vertex)
cam_erdp <- ones_erdp - as_adj(g_erdp)
scam_erdp <- eigen(cam_erdp)
temp_adj_comp[iter,] <- scam_erdp$values
# of laplacian matrix
lm_erdp <- laplacian_matrix(g_erdp,
normalized = FALSE)
sl_erdp <- eigen(lm_erdp)
temp_lap[iter,] <- sl_erdp$values
# of normalized laplacian matrix
lmn_erdp <- laplacian_matrix(g_erdp,
normalized = TRUE)
sln_erdp <- eigen(lmn_erdp)
temp_lapn[iter,] <- sln_erdp$values
# of spectrum density
temp_density[[iter]] <- fast.spectral.density(g_erdp,
npoints = npoints, # refinar mais essa busca
numCores = numCores)
# of classifier article
Bline <- createBline(g_erdp)
Bline_eigen <- eigen(Bline)
temp_Bline[iter,] <- Bline_eigen$values
absolute_eigen <- base::Mod(Bline_eigen$values)
log_base <- max(absolute_eigen) # the spectral radius
rescale_eigen <- log(absolute_eigen,
base = log_base)
temp_B_eigen[iter,] <- rescale_eigen
temp_B_eigen_resc[iter,] <- complex(modulus = rescale_eigen,
argument = Arg(Bline_eigen$values))
temp_ecsd[[iter]] <- ecsd(r_interval = r_int,
pi_interval = pi_int,
rescale_eigen = rescale_eigen,
n = vertex,
Bline_eigen = Bline_eigen)
temp_ecsd_rbind <- rbind(temp_ecsd_rbind, temp_ecsd[[iter]])
}
assign(name_adj, temp_adj)
remove(temp_adj, s_erdp)
assign(name_adj_comp, temp_adj_comp)
remove(temp_adj_comp, scam_erdp, ones_erdp, cam_erdp)
assign(name_lap, temp_lap)
remove(temp_lap, sl_erdp, lm_erdp)
assign(name_lapn, temp_lapn)
remove(temp_lapn, sln_erdp, lmn_erdp)
assign(name_dens, temp_density)
remove(temp_density, name_dens)
assign(name_Bline, temp_Bline)
assign(name_B_eigen, temp_B_eigen)
assign(name_B_eigen_resc, temp_B_eigen_resc)
assign(name_ecsd, temp_ecsd)
temp_ecsd_rbind<-temp_ecsd_rbind[rowSums(is.na(temp_ecsd_rbind)) != ncol(temp_ecsd_rbind),]
assign(name_ecsd_rbind, temp_ecsd_rbind)
remove(Bline, Bline_eigen, temp_Bline, absolute_eigen, log_base, temp_B_eigen,
temp_B_eigen_resc, temp_ecsd, temp_ecsd_rbind)
}
}
remove(g_erdp, iter, n_vertex, max_iter, p, name_adj,
name_adj_comp, name_lap, name_lapn, prob, vertex,
name_Bline, name_B_eigen, name_B_eigen_resc,
rescale_eigen, createBline, ecsd, name_ecsd,
name_ecsd_rbind, create_interval, r_int, pi_int,
numCores, npoints, length_int)
save.image("~/Área de Trabalho/teste.RData")
max_iter <- 10#00
library(igraph)
library(statGraph)
source("/home/matheus/Dropbox/06_doutorado/simulations/graph_spectrum/createBline.R")
source("/home/matheus/Dropbox/06_doutorado/simulations/graph_spectrum/createECSD.R")
create_interval <- function(from, to, length.out) {
length.out <- length.out + 1
result <- seq(from, to, length.out = length.out)
result <- result[-1]
return(result)
}
# mudar depois para refinar mais o interval
length_int <- 10
npoints <- 20
numCores <- 2
## ERDOS-RENYI with probabilities
n_vertex <- c(100,200,500,1000,5000,10000)
prob <- c(0.1, 0.3, 0.5, 0.7, 0.9)
max_iter <- 10#00
r_int <- create_interval(0,1,length_int)
pi_int <- create_interval(0,pi,length_int)
for (vertex in n_vertex){
for (p in prob){
name_adj <- paste("er_eigen_adj_n_",vertex,"_p_", p, sep = "")
name_adj_comp <- paste("er_eigen_adjcomple_n_",vertex,"_p_", p, sep = "")
name_lap <- paste("er_eigen_laplac_n_",vertex,"_p_", p, sep = "")
name_lapn <- paste("er_eigen_laplacNorm_n_",vertex,"_p_", p, sep = "")
name_dens <- paste("er_density_n_",vertex,"_p_", p, sep = "")
name_Bline <- paste("er_BLine_n_",vertex,"_p_", p, sep = "")
name_B_eigen <- paste("er_B_eigenReal_n_",vertex,"_p_", p, sep = "")
name_B_eigen_resc <- paste("er_B_eigen_R_and_Im_n_",vertex,"_p_", p, sep = "")
name_ecsd <- paste("er_ecsd_n_",vertex,"_p_", p, sep = "")
name_ecsd_rbind <- paste("er_ecsd_rbind_n_",vertex,"_p_", p, sep = "")
temp_adj <- matrix(nrow = max_iter,
ncol = vertex)
temp_adj_comp <- matrix(nrow = max_iter,
ncol = vertex)
temp_lap <- matrix(nrow = max_iter,
ncol = vertex)
temp_lapn <- matrix(nrow = max_iter,
ncol = vertex)
temp_density <- list()
temp_Bline <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_B_eigen <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_B_eigen_resc <- matrix(nrow = max_iter,
ncol = vertex*2)
temp_ecsd <- list()
temp_ecsd_rbind <- matrix(nrow = length_int,
ncol = length_int)
for (iter in 1:max_iter){
# of adjacency matrix
g_erdp <- erdos.renyi.game(n=vertex,
p.or.m=p,
type = c("gnp"),
directed = FALSE,
loops = FALSE)
s_erdp <- eigen(as_adj(g_erdp))
temp_adj[iter,] <- s_erdp$values
# of complementary adjacency matrix
ones_erdp <- matrix(data=1,
nrow=vertex,
ncol=vertex)
cam_erdp <- ones_erdp - as_adj(g_erdp)
scam_erdp <- eigen(cam_erdp)
temp_adj_comp[iter,] <- scam_erdp$values
# of laplacian matrix
lm_erdp <- laplacian_matrix(g_erdp,
normalized = FALSE)
sl_erdp <- eigen(lm_erdp)
temp_lap[iter,] <- sl_erdp$values
# of normalized laplacian matrix
lmn_erdp <- laplacian_matrix(g_erdp,
normalized = TRUE)
sln_erdp <- eigen(lmn_erdp)
temp_lapn[iter,] <- sln_erdp$values
# of spectrum density
temp_density[[iter]] <- fast.spectral.density(g_erdp,
npoints = npoints, # refinar mais essa busca
numCores = numCores)
# of classifier article
Bline <- createBline(g_erdp)
Bline_eigen <- eigen(Bline)
temp_Bline[iter,] <- Bline_eigen$values
absolute_eigen <- base::Mod(Bline_eigen$values)
log_base <- max(absolute_eigen) # the spectral radius
rescale_eigen <- log(absolute_eigen,
base = log_base)
temp_B_eigen[iter,] <- rescale_eigen
temp_B_eigen_resc[iter,] <- complex(modulus = rescale_eigen,
argument = Arg(Bline_eigen$values))
temp_ecsd[[iter]] <- ecsd(r_interval = r_int,
pi_interval = pi_int,
rescale_eigen = rescale_eigen,
n = vertex,
Bline_eigen = Bline_eigen)
temp_ecsd_rbind <- rbind(temp_ecsd_rbind, temp_ecsd[[iter]])
}
assign(name_adj, temp_adj)
remove(temp_adj, s_erdp)
assign(name_adj_comp, temp_adj_comp)
remove(temp_adj_comp, scam_erdp, ones_erdp, cam_erdp)
assign(name_lap, temp_lap)
remove(temp_lap, sl_erdp, lm_erdp)
assign(name_lapn, temp_lapn)
remove(temp_lapn, sln_erdp, lmn_erdp)
assign(name_dens, temp_density)
remove(temp_density, name_dens)
assign(name_Bline, temp_Bline)
assign(name_B_eigen, temp_B_eigen)
assign(name_B_eigen_resc, temp_B_eigen_resc)
assign(name_ecsd, temp_ecsd)
temp_ecsd_rbind<-temp_ecsd_rbind[rowSums(is.na(temp_ecsd_rbind)) != ncol(temp_ecsd_rbind),]
assign(name_ecsd_rbind, temp_ecsd_rbind)
remove(Bline, Bline_eigen, temp_Bline, absolute_eigen, log_base, temp_B_eigen,
temp_B_eigen_resc, temp_ecsd, temp_ecsd_rbind)
}
}
remove(g_erdp, iter, n_vertex, max_iter, p, name_adj,
name_adj_comp, name_lap, name_lapn, prob, vertex,
name_Bline, name_B_eigen, name_B_eigen_resc,
rescale_eigen, createBline, ecsd, name_ecsd,
name_ecsd_rbind, create_interval, r_int, pi_int,
numCores, npoints, length_int)
View(Bline)
View(er_B_eigenReal_n_100_p_0.1)
x <- c(4,5,3,6,7,8,4)
t <- t.test(x, mu=3, alternative = "greater")
plot(t)
t
plot(cars)
plot(cars)
plot(cars)
plot(cars)
load("/dataset/titanic3.sav")
load("../dataset/titanic3.sav")
load("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/titanic3.sav")
setwd("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/")
---
title: "Análise Exploratória - Titanic"
output: html_notebook
editor_options:
chunk_output_type: inline
knitr::opts_knit$set(root.dir = normalizePath("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/"))
---
c
knitr::opts_knit$set(root.dir = normalizePath("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/"))
load("titanic3.sav")
summary(titanic3)
head(titanic3)
load("titanic2.sav")
View(titanic3)
View(titanic2)
load("titanic1.sav")
load("titanic.sav")
View(titanic)
View(titanic3)
remove(titanic, titanic2)
plsmo(age, survived, group=sex, datadensity=T) # or group=pclass
plot(naclus(titanic3)) # study patterns of missing values
summary(survived ~ age + sex + pclass + sibsp + parch, data=titanic3)
load("titanic3.sav")
# Summary
```{r}
head(titanic3)
```
Explicações sobre as colunas do dataset [titanic3](https://hbiostat.org/data/repo/titanic.html):
* **pclass**: Tipo de classe que o passageiro estava. 1 é a primeira classe e 3 é a pior classe.
* **survived**: Informa se o passageiro sobreviveu (1) ou não (0).
* **name**: Nome do passageiro.
* **sex**: Sexo do passageiro, masculino ou feminino.
* **age**: Idade do passageiro.
---
title: "Análise Exploratória - Titanic"
output: html_notebook
editor_options:
chunk_output_type: inline
---
```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = normalizePath("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/"))
```
knitr::opts_knit$set(root.dir = normalizePath("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/"))
load("titanic3.sav")
head(titanic3)
# Load dataset
```{r}
knitr::opts_knit$set(root.dir = normalizePath("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/"))
load("titanic3.sav")
head(titanic3)
knitr::opts_knit$set(root.dir = normalizePath("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/"))
load("titanic3.sav")
knitr::opts_knit$set(root.dir = normalizePath("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/"))
head(titanic3)
dim(titanic3)
summary(titanic3)
str(titanic3)
sapply(titanic3, class)
sapply(titanic3, typeof)
print(sapply(titanic3, typeof))
print(sapply(titanic3, class))
print(sapply(titanic3, typeof))
print("Classes:")
print(sapply(titanic3, class))
print("Classes:")
print(sapply(titanic3, typeof))
describe(titanic3)
library("Hmisc")
describe(titanic3)
describe(titanic3)
#####
# Load file
load("titanic3.RData")
## "Exploratory Analysis - Titanic"
## Analysis
## @ Matheus Pimenta
## github.com/omatheuspimenta/titanic_exploratory
###########################################################
#####
# Set path
setwd("/home/matheus/Dropbox/06_doutorado/2021_01/Bioestatistica/projeto/dataset/")
#####
# Load file
load("titanic3.RData")
table(titanic3$pclass)
t<-table(titanic3$pclass)
tt <- tapply(titanic3$survived, titanic3$pclass, sum)
tt/t
tapply(titanic3$survived, titanic3$pclass, sum) / table(titanic3$pclass)
#####
# Libraries
library("ggplot2") #for graphics
library("dplyr") #for summary
library("plyr") #for count
# 0  1
# 30 16
# families with high number of survived
t<-count(titanic3[titanic3$survived==1,], 'lastname')
t<-t[order(t$freq, decreasing = TRUE),]
ylim <- c(0, 1.1*max(t$freq))
xx <- barplot(t$freq[1:10],
col = rainbow(20),
main = "Barplot - Families/Survived",
xlab = "Families",
ylab = "Frequency",
ylim = ylim)
text(x = xx, y = t$freq[1:10], label = t$freq[1:10], pos = 3, cex = 0.8, col = "black")
axis(1, at=xx, labels=t$lastname[1:10], tick=FALSE, las=2, line=-0.5, cex.axis=0.8)
# select subset from dataframe
# pclass numeric
titanic3$class <- ifelse(titanic3$pclass=="1st",1,ifelse(titanic3$pclass=="2nd",2,ifelse(titanic3$pclass=="3rd",3,0)))
df_cor <- select(titanic3, class, survived, age, fare, nfamily, mom)
# correlation matrix
cormat <- round(cor(df_cor),2)
cormat_melted <- melt(cormat)
library("reshape2") #for melted matrix
cormat_melted <- melt(cormat)
# Create a ggheatmap
ggheatmap <- ggplot(cormat_melted, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation")  +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
print(ggheatmap)
# graph
ggheatmap +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4)
#remove temp variables
remove(ggheatmap, cormat, cormat_melted)
# Pearson's product-moment correlation
# data:  df_cor$class and df_cor$fare
# t = -24.353, df = 1307, p-value < 2.2e-16
# alternative hypothesis: true correlation is not equal to 0
# 95 percent confidence interval:
#  -0.5948682 -0.5202611
# sample estimates:
#        cor
# -0.5586939
# remove temp variables
remove(df_cor)
# scatterplot
# age/fare/class
p<-ggplot(titanic3, aes(x=age, y=fare, color=pclass)) +
geom_point(size=3)
p + labs(title = "Scatterplot - Age/Fare",
x="Age (years)",
y="Fare") +
labs(colour = "Class")
